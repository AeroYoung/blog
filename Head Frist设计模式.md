# 《Head Frist 设计模式》
* by E & E Freeman, K Sierra, B Bates
* ISBN 978-7-5083-5383-7

## 策略模式

软件开发唯一不变的地方就是"CHANGE"

**第一个设计原则**：把会变化的部分取出来封装，而不影响不变化的部分。

**第二个设计原则**：针对接口编程，而不是针对实现。

**第三个设计原则**：多用组合少用继承。因为软件开发“后”花的时间其实比开发过程更多，所以要提高代码的复用性。所谓组合，就是将多个类结合起来用。

所以就有了第一个设计模式:**策略模式**
>定义算法族，分别封装起来，让它们之间可以相互替换。如此可让算法本体的变化独立于算法的客体。__

## 观察者模式

报纸+订阅者 = 观察者模式
>定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并更新。

**松耦合**：对象之间可以交互，但是不太清楚彼此的细节。
**设计原则**：为了交互对象之间松耦合而努力。

接口只定义了抽象的方法，但没有具体的实现。

## 装饰者模式
在运行时装饰类和不是在编译时继承。

**设计原则** 努力使得类易于扩展而不用修改现有代码。
>装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

装饰者和被装饰者必须是相同的类型，所以需要用到继承达到类型匹配，再用组合和基础组件获得行为。
装饰者富有弹性，但是会有很多小类，设计方式也不太易于理解。如果有些代码针对特定的类型，使用装饰者会导致Bug,所以导出装饰者必须小心谨慎一些。

## 工厂模式

实例化具体的类将使得后续维护和更新的成本大大增加。
**工厂**：将创建对象的代码封装到另一个对象中，该对象即叫工厂，它处理创建对象的细节。
>工厂模式：定义了一个创建对象的接口，但由子类来决定要实例化哪一个类。工厂模式保护创建者和产品两类对象。

所谓决定，意思是选择使用哪一个子类，也就决定了实际创建的产品是什么。这样一来，如果后续要增加新的产品/子类，增加即可，不用修改前面的任何代码。因为实例化一个对象，就是依赖于它的具体类。
**设计原则**:又叫**依赖倒置原则**,要依赖抽象而不是具体类。
* 变量不可以持有具体类的引用(如果用new，那就可以考虑用一个工厂)
* 不要让类派生自具体类
* 不要覆盖基类中已经实现的方法(基类中已实现的方法应该由所有的子类共享)

>抽象工厂模式：提供一个接口，用于创建相关或者依赖对象族，而不需要明确指定具体类。

## 单件模式
一个类只有一个实例。常常被用来管理数据库连接或者线程池。
>确保一个类只有一个实例，并提供一个全局访问点。

可以用同步(synchronized)的方式保证每个线程进入这个方法之前要先等候别的线程离开这个方法。但是这样会造成性能浪费。所以可以在静态初始化器中创建单件，加载这个类的时候便创建该实例。

## 命令模式

将发出请求的对象和接收并执行这些请求的对象解耦。
>将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

空对象有时候也被视为一种设计模式