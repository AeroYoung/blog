# 《Head Frist 设计模式》
* by E & E Freeman, K Sierra, B Bates
* ISBN 978-7-5083-5383-7

## 策略模式

软件开发唯一不变的地方就是"CHANGE"

**第一个设计原则**：把会变化的部分取出来封装，而不影响不变化的部分。

**第二个设计原则**：针对接口编程，而不是针对实现。

**第三个设计原则**：多用组合少用继承。因为软件开发“后”花的时间其实比开发过程更多，所以要提高代码的复用性。所谓组合，就是将多个类结合起来用。

所以就有了第一个设计模式:**策略模式**
>定义算法族，分别封装起来，让它们之间可以相互替换。如此可让算法本体的变化独立于算法的客体。__

## 观察者模式

报纸+订阅者 = 观察者模式
>定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并更新。

**松耦合**：对象之间可以交互，但是不太清楚彼此的细节。
**设计原则**：为了交互对象之间松耦合而努力。

接口只定义了抽象的方法，但没有具体的实现。

## 装饰者模式
在运行时装饰类和不是在编译时继承。

**设计原则** 努力使得类易于扩展而不用修改现有代码。
>装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

装饰者和被装饰者必须是相同的类型，所以需要用到继承达到类型匹配，再用组合和基础组件获得行为。
装饰者富有弹性，但是会有很多小类，设计方式也不太易于理解。如果有些代码针对特定的类型，使用装饰者会导致Bug,所以导出装饰者必须小心谨慎一些。

## 工厂模式

实例化具体的类将使得后续维护和更新的成本大大增加。
**工厂**：将创建对象的代码封装到另一个对象中，该对象即叫工厂，它处理创建对象的细节。
>工厂模式：定义了一个创建对象的接口，但由子类来决定要实例化哪一个类。工厂模式保护创建者和产品两类对象。

所谓决定，意思是选择使用哪一个子类，也就决定了实际创建的产品是什么。这样一来，如果后续要增加新的产品/子类，增加即可，不用修改前面的任何代码。因为实例化一个对象，就是依赖于它的具体类。
**设计原则**:又叫**依赖倒置原则**,要依赖抽象而不是具体类。
* 变量不可以持有具体类的引用(如果用new，那就可以考虑用一个工厂)
* 不要让类派生自具体类
* 不要覆盖基类中已经实现的方法(基类中已实现的方法应该由所有的子类共享)

>抽象工厂模式：提供一个接口，用于创建相关或者依赖对象族，而不需要明确指定具体类。

## 单件模式
一个类只有一个实例。常常被用来管理数据库连接或者线程池。
>确保一个类只有一个实例，并提供一个全局访问点。

可以用同步(synchronized)的方式保证每个线程进入这个方法之前要先等候别的线程离开这个方法。但是这样会造成性能浪费。所以可以在静态初始化器中创建单件，加载这个类的时候便创建该实例。

## 命令模式

将发出请求的对象和接收并执行这些请求的对象解耦。
>将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

空对象有时候也被视为一种设计模式。
## 适配器模式
>将一个类的接口转化成另一个类的接口。让原本接口不兼容的类可以合作无间。

适配器的工作量和接口大小成正比，但是他把所有的变化都封装到了一个类中，不用改变原有的代码，这样是比较好比较安全的。以上又被称为**对象适配器**

## 外观模式
>提供一个统一的接口用来访问子系统中的一群接口。

**设计原则**：最少知识原则，减少对象之间的交互。

## 模板方法模式
模板方法定义了算法的步骤，然后让子类实现一个或多个步骤。
>在一个方法中定义算法的股价，而将步骤的实现延迟到子类中。这样使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

具体来说就在在基类中定义一个final的模板方法，以免子类改变算法的顺序。然后定义一系列算法的步骤，将必须由子类实现的方法定义为抽象方法。当该步骤必须实现的时候就用抽象方法，如果这部分是可选的，那就加入一个钩子函数。
**设计原则**:好莱坞原则，别调用我们，我们会调用你。我们指的是高层组件，你们指的是低层组件。
在模板方法模式中，基类就是高层组件由他来控制算法流程，子类只负责具体实现，只有当药实现某种方法的时候才调用对应的子类。

## 迭代器和组合模式
>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

迭代器完成游走的任务，而不是在聚合上。这样简化了聚合的接口和实现，也让责任各得其所。

**设计原则**：一个类应该只有一个引起变化的原因。即所谓的内聚。

## 状态模式